#
# ********************************
# Smoothing options and what-not
# taken from SOSE
# ********************************
 &SMOOTH_NML
#for x4, 100 is ok, for x8, need 300, x16: need 1200, else get bogus outputs
# smooth2Dnbt(1)=100,
 smooth2Dnbt(1)=300,
# smooth2Dnbt(1)=1200,
#combo of type~=0 & size =2 will read in scale file
#else it will read variable smooth2D_L[x/y]0
 smooth2Dtype(1)=1,
 smooth2Dsize(1)=2,
#the scale file has size [nx ny 2] and is a simple
#stack of dxg (:,:,1) and dyg (:,:,2)
#so the design of smooth2D_L[x,y]0 can be roughly the mean
#length of dxy and dyg, if we want to just use a single num
# smooth2D_Lx0(1)=50000.
# smooth2D_Ly0(1)=50000.
 smooth2Dfilter(1)=0,
##
#
#CMM=> smooth2Dfilter must be 1 first time
#CCM so initializes normalization matrix
# and for 3D
# smooth3Dnbt(1)=100,
 smooth3Dnbt(1)=300,
# smooth3Dnbt(1)=1200,
#type: 1 is based on model grid, 2 or 3 is gmredi, 4 is something..
 smooth3DtypeH(1)=1,
 smooth3DtypeZ(1)=1,
#size: 3 is reading from file smooth3DscalesZ00X or smooth3DscalesH00X
 smooth3DsizeH(1)=3,
 smooth3DsizeZ(1)=3,
#the scale file has size [nx ny nz 2] and is a simple
#stack of dxg for (:,:,1:50) and dyg for (:,:,51:100)
#so the design of smooth3D_L[x,y]0 can be roughly the mean
#length of dxy and dyg, if we want to just use a single num
#
#These three numbers smooth3D_L[x,y,z]0 are only read in if size
#is NOT 3, meaning it would read in a CONSTANT as listed below.
#So best to just comment them all out since we read from files.
# smooth3D_Lx0(1)=50000.,
# smooth3D_Ly0(1)=50000.,
# smooth3D_Lz0(1)=10.,
 smooth3Dfilter(1)=0,
#
#smooth3DtotTime = smooth3Dnbt(smoothOpNb)*smooth3DdelTime(=1)
#smooth3D_Kux(i,j,k,bi,bj) = smooth3D_Lx0*smooth3D_Lx0
#         /smooth3DtotTime/2
#smooth3D_Kvy(i,j,k,bi,bj) = smooth3D_Ly0*smooth3D_Ly0
#         /smooth3DtotTime/2
 /
